from flask import Flask, jsonify, request
from flask_cors import CORS
import pandas as pd
import os
import jso    except Exception as e:
        import traceback
        error_trace = traceback.format_exc()
        print(f"Error in get_props_for_frontend: {str(e)}")
        print(error_trace)
        return jsonify({
            "error": f"Failed to format props: {str(e)}",
            "trace": error_trace if app.debug else "Enable debug mode for detailed error"
        }), 500
from datetime import datetime
from pick_player_props import load_props, find_player_props  # adjust import

app = Flask(__name__)
CORS(app)

# Load props once (or reload each request if CSV updates often)
try:
    df = load_props()
    print("Props loaded successfully")
    if df is not None:
        print(f"Found {len(df)} props")
    else:
        print("Props file was found but DataFrame is None")
except Exception as e:
    print(f"Error loading props: {str(e)}")
    df = None

# Helper function to load past picks from CSV files
def load_past_picks():
    past_picks = []
    data_dir = os.path.join(os.path.dirname(__file__), "Data")
    
    if not os.path.exists(data_dir):
        return past_picks
        
    for filename in os.listdir(data_dir):
        if filename.startswith("my_picks_") and filename.endswith(".csv"):
            try:
                file_path = os.path.join(data_dir, filename)
                picks_df = pd.read_csv(file_path)
                
                # Parse date from filename
                date_str = filename.replace("my_picks_", "").replace(".csv", "")
                date_parts = date_str.split("_")
                if len(date_parts) == 2:
                    date = date_parts[0]
                    time = date_parts[1][:2] + ":" + date_parts[1][2:] if len(date_parts[1]) >= 4 else date_parts[1]
                    formatted_date = f"{date} {time}"
                else:
                    formatted_date = date_str
                
                # Read additional info from file
                bet = 10.0  # Default
                multiplier = 1.0  # Default
                won = False  # Default
                mode = "PowerPlay"  # Default
                
                # Try to read extra info from file content
                with open(file_path, 'r') as f:
                    lines = f.readlines()
                    for line in lines:
                        if "Bet: $" in line:
                            try:
                                bet = float(line.split("$")[1].strip())
                            except:
                                pass
                        elif "Multiplier:" in line:
                            try:
                                multiplier = float(line.split("Multiplier:")[1].split("x")[0].strip())
                            except:
                                pass
                        elif "PowerPlay Payout:" in line:
                            mode = "PowerPlay"
                            try:
                                payout = float(line.split("$")[1].strip())
                                won = True  # Assuming a payout means they won
                            except:
                                payout = bet * multiplier
                        elif "Flexed Payout:" in line:
                            mode = "Flex"
                            try:
                                payout = float(line.split("$")[1].strip())
                                won = True  # Assuming a payout means they won
                            except:
                                payout = bet * multiplier
                
                # Create pick slip object
                picks = []
                for _, row in picks_df.iterrows():
                    if 'player' in row and pd.notna(row['player']):  # Skip non-pick rows
                        picks.append({
                            'player': row['player'],
                            'stat': row['stat'],
                            'line': row['line'],
                            'pick': row['pick']
                        })
                
                if picks:  # Only add if there are actual picks
                    past_picks.append({
                        'date': formatted_date,
                        'picks': picks,
                        'bet': bet,
                        'multiplier': multiplier,
                        'payout': payout if won else 0,
                        'mode': mode,
                        'won': won
                    })
            except Exception as e:
                print(f"Error loading {filename}: {e}")
                
    return past_picks

@app.route("/api/props", methods=["GET"])
def get_all_props():
    try:
        if df is None:
            return jsonify({"error": "Props data not available. Try running the scraper first."}), 404
        
        # Handle NaN values
        import json
        class NaNHandler(json.JSONEncoder):
            def default(self, obj):
                if pd.isna(obj):
                    return None
                return super().default(obj)
                
        return app.response_class(
            response=json.dumps(df.replace({pd.NA: None}).to_dict(orient="records"), cls=NaNHandler),
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        return jsonify({"error": f"Failed to get props: {str(e)}"}), 500

@app.route("/api/props/player/<player_name>", methods=["GET"])
def get_player_props(player_name):
    try:
        if df is None:
            return jsonify({"error": "Props data not available. Try running the scraper first."}), 404
        if not player_name or len(player_name) < 2:
            return jsonify({"error": "Player name must be at least 2 characters"}), 400
            
        matches = find_player_props(df, player_name)
        
        if matches.empty:
            return jsonify({"error": f"No props found for player: {player_name}", "matches": []}), 404
            
        # Handle NaN values
        import json
        class NaNHandler(json.JSONEncoder):
            def default(self, obj):
                if pd.isna(obj):
                    return None
                return super().default(obj)
                
        return app.response_class(
            response=json.dumps(matches.replace({pd.NA: None}).to_dict(orient="records"), cls=NaNHandler),
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        return jsonify({"error": f"Failed to get player props: {str(e)}"}), 500

@app.route("/api/props/formatted", methods=["GET"])
def get_props_for_frontend():
    try:
        if df is None:
            return jsonify({"error": "Props data not available. Try running the scraper first."}), 404
            
        # Ensure keys: player, stat, value, sport
        props = []
        processed = set()  # To avoid duplicates
        
        # For debugging
        print(f"DataFrame columns: {df.columns.tolist()}")
        
        # Check if limit parameter is provided in the request
        limit_param = request.args.get('limit')
        if limit_param is not None:
            try:
                limit = int(limit_param)
            except ValueError:
                limit = None  # No limit if parameter is invalid
        else:
            limit = None  # No limit by default
            
        counter = 0
        
        for _, row in df.iterrows():
            # Get the key fields, with fallbacks for different column names
            player_value = row.get("full_name")
            player = player_value if pd.notna(player_value) else "Unknown Player"
            
            # Try different possible column names for the stat
            stat = None
            for stat_col in ["stat_name", "type_over_under", "selection_subheader"]:
                if stat_col in row and pd.notna(row[stat_col]):
                    stat = row[stat_col]
                    break
            
            if stat is None or pd.isna(stat):
                stat = "Unknown Stat"
                
            # Try different possible column names for the value
            value = None
            for val_col in ["stat_value", "line", "value", "non_discounted_stat_value"]:
                if val_col in row and pd.notna(row[val_col]):
                    value = row[val_col]
                    break
                    
            if value is None or pd.isna(value):
                value = "0"
            
            # Try different possible column names for the sport
            sport = "Unknown Sport"
            for sport_col in ["sport_id", "sport", "sport_name", "league", "league_id"]:
                if sport_col in row and pd.notna(row[sport_col]):
                    sport = row[sport_col]
                    break
                    
            # Make sure sport is not NaN
            if pd.isna(sport):
                sport = "Unknown Sport"
            
            # Create a unique key to avoid duplicate props
            key = f"{player}|{stat}|{value}"
            if key in processed:
                continue
                
            processed.add(key)
            
            props.append({
                "player": player,
                "stat": stat,
                "value": value,
                "sport": sport  # Add sport to each prop
            })
            
            counter += 1
            if limit is not None and counter >= limit:
                break
            
        if not props:
            # Create some sample data if no props found
            print("No valid props found, adding sample data")
            sample_players = [
                {"player": "LeBron James", "stat": "pts", "value": "25.5", "sport": "NBA"},
                {"player": "Stephen Curry", "stat": "pts", "value": "28.5", "sport": "NBA"},
                {"player": "Giannis Antetokounmpo", "stat": "pts", "value": "30.5", "sport": "NBA"},
                {"player": "Nikola Jokic", "stat": "ast", "value": "9.5", "sport": "NBA"},
                {"player": "Joel Embiid", "stat": "pts", "value": "29.5", "sport": "NBA"}
            ]
            props.extend(sample_players)
            
        print(f"Returning {len(props)} props")
        # Use json.dumps with a custom encoder to handle NaN values
        import json
        class NaNHandler(json.JSONEncoder):
            def default(self, obj):
                if pd.isna(obj):
                    return None
                return super().default(obj)
                
        # Convert to JSON with NaN handling, then return
        return app.response_class(
            response=json.dumps(props, cls=NaNHandler),
            status=200,
            mimetype='application/json'
        )
    except Exception as e:
        import traceback
        error_trace = traceback.format_exc()
        print(f"Error in formatting props: {str(e)}")
        print(error_trace)
        
        # Create some sample data as fallback
        sample_players = [
            {"player": "LeBron James", "stat": "pts", "value": "25.5", "sport": "NBA"},
            {"player": "Stephen Curry", "stat": "pts", "value": "28.5", "sport": "NBA"},
            {"player": "Giannis Antetokounmpo", "stat": "pts", "value": "30.5", "sport": "NBA"}
        ]
        return jsonify({
            "error": f"Failed to format props: {str(e)}",
            "sample_data": sample_players
        }), 500
    
# Keep backward compatibility for now with a redirect
@app.route("/props", methods=["GET"])
def legacy_props_route():
    return get_props_for_frontend()

@app.route("/api/past-picks", methods=["GET"])
def get_past_picks():
    try:
        past_picks = load_past_picks()
        if not past_picks:
            return jsonify({
                "message": "No past picks found. Make some picks first!",
                "picks": []
            })
        return jsonify(past_picks)
    except Exception as e:
        return jsonify({
            "error": f"Failed to load past picks: {str(e)}",
            "picks": []
        }), 500

if __name__ == "__main__":
    app.run(debug=True)
